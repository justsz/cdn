<!DOCTYPE html>
<!-- basic drawing capability taken from url=(0040)http://bl.ocks.org/mbostock/raw/2429963/ -->
<!-- some tree stuff inspired by https://gist.github.com/kueda/1036776 -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8">
		<title>A tree</title>
		<link rel="stylesheet" type="text/css" href="stylesheets/treeStyles.css">
		<script src="javascript/d3.v3.min.js"></script>
	</head>
<body>
<!-- <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->


<script>

var width = 400,
    height = 500,
    marginForLabels = 100;
    
var frameData = [];
	
//var sortedAscending = false;



	
//d3.select("p")
//	.on("click", sortLeaves);

var counter = 0;
var focusedFrame = 0;
	
var inputFiles = ["data/tree1.json", "data/tree2.json"];
//var inputFiles = ["data/testTree2.json", "data/testTree2.json"];



//read each input file and draw the tree in its own div
for (var i = 0; i < inputFiles.length; i++) {
	console.log("reading " + inputFiles[i]);
	initializeTree(inputFiles[i]);
}



	
function initializeTree(filename) {
	d3.json(filename, function(root) {
	//root is the root node of the input tree
	
		focusedFrame = counter;
		//initialize d3 cluster layout
		var cluster = d3.layout.cluster()
		    .size([height, width - marginForLabels])
			.separation( function(a, b) { return 1; } );

		//get an array of all nodes and where they should be placed 
		//(ignoring branch lengths)
		var nodes = cluster.nodes(root);
		var linkData = cluster.links(nodes);
		
		attachLinkReferences(nodes, linkData);

		var xScale = scaleBranchLengths(nodes, width - marginForLabels);
		
		var yScale = d3.scale.linear()
			.domain([0, height])
			.range([0, height]);
		
		var brush = d3.svg.brush()
			//.x(d3.scale.linear().domain([0, width]).range([0, width]))
			.y(yScale)
	    	.on("brushstart", brushstart)
		    .on("brush", brushmove)
    		.on("brushend", brushend);
	
		var div = d3.select("body").append("div")
			.attr("class", "svgBox");
	
		var svg = div.append("svg")
			.attr("id", counter)	//append a number to later identify this svg
			.attr("width", width)
			.attr("height", height)		
			.append("g")
				.attr("transform", "translate(35, 0)");
			


		var zoom = d3.behavior.zoom()
			//.x(xScale)
			.y(yScale)
			.on("zoom", zoomed)		
			.scaleExtent([1, 10]);
			
		frameData.push({x:xScale, y:yScale, brush:brush, zoom:zoom});
		
		var links = svg.selectAll("path.link")
			.data(linkData, getLinkKey)
		.enter().append("path")
		    .attr("class", "link")
			.attr("d", elbow)

		//assign node classification and position it
		var node = svg.selectAll("g.node")
			.data(nodes, getNodeKey)
		.enter().append("g")
			.attr("class", function(d) {
				if (d.children) {
					if (d.depth == 0) {
						return "root node";
					} else {
						return "inner node";
					}
				} else {
					return "leaf node";
				}
			} )
		 	.attr("transform", function(d) { return "translate(" + (d.y) + "," + yScale(d.x) + ")"; });
			
		//draw root node line. It is placed inside the root nodes g so it transforms along with it.
	    svg.select(".root") 
			.append("path")
	    	.attr("class", "rootLink")
			.attr("d", function(d) {return "M" + 0 + "," + 0 + "h" + -20; });		

		svg.selectAll(".leaf").append("text")
			.attr("dx", 8)
			.attr("dy", 3)
			.attr("text-anchor", "start" )
			.text(function(d) { return d.name; });
		
		svg.selectAll(".leaf").append("path")
			.attr("class", "dashedLink")
			.attr("d", dashedElbow);	
			
		svg.append("rect")
			.attr("class", "scrollArea")
			.attr("x", width - 60)
			.attr("y", 0)
			.attr("rx", 10)
			.attr("ry", 10)
			.attr("width", 20)
			.attr("height", height)	
			.call(zoom)
			
		svg.append("rect")
			.attr("width", width - marginForLabels)
			.attr("height", height)
			.attr("class", "brushBox")
			.call(brush);
			
		counter++;
	});
}

function attachLinkReferences(nodes, linkData) {
	for (var i = 1; i < nodes.length; i++) {
		for (var j = 0; j < linkData.length; j++) { //can this be done a bit faster?
			if (nodes[i] === linkData[j].target) {
				nodes[i].uplink = linkData[j];
				break;
			}
		}
	}
}

function getNodeLinks(nodes) {
	var links = []
	for (var i = 0; i < nodes.length; i++) {
		links.push(nodes[i].uplink);				
	}
	return links;		
}


var elbow = function(d, i) {
  return "M" + frameData[focusedFrame].x(d.source.rootDist) + "," + frameData[focusedFrame].y(d.source.x)
      + "V" + frameData[focusedFrame].y(d.target.x) + "H" + frameData[focusedFrame].x(d.target.rootDist);
}

var dashedElbow = function(d, i) {
	return "M" + 0 + "," + 0
    	+ "h" + (frameData[focusedFrame].x(d.rootDist) - d.y);
}

function scaleBranchLengths(nodes, w) {
	// Visit all nodes and adjust y pos width distance metric
	var visitPreOrder = function(root, callback) {
    	callback(root);
    	if (root.children) {
        	for (var i = 0; i < root.children.length; i++){
          		visitPreOrder(root.children[i], callback);
        	};
      	}
    }
    
    visitPreOrder(nodes[0], function(node) {
      node.rootDist = (node.parent ? node.parent.rootDist : 0) + (node.length || 0);
    });
    
    var rootDists = nodes.map(function(n) { return n.rootDist; });
    var yscale = d3.scale.linear()
      .domain([0, d3.max(rootDists)])
      .range([0, w]);
      
    //visitPreOrder(nodes[0], function(node) {
    //  node.y = yscale(node.rootDist);
    //});
    
    return yscale;
}


function zoomed() {
	var svg = d3.select(this.parentNode);
	focusedFrame = this.parentNode.parentNode.id;
	//if (!brush.empty())
	//	svg.call(brush.clear());
	
	
	var link = svg.selectAll("path.link")
		.attr("d", elbow);

	var node = svg.selectAll("g.node")
		.attr("transform", function(d) { return "translate(" + (d.y) + "," + frameData[focusedFrame].y(d.x) + ")"; })
}

//var prevCell;

// Clear the previously-active brush, if any.
function brushstart(p) {
 	//var cell = d3.select(this);
	var newFocusedFrame = this.parentNode.parentNode.id;
 
 	if (newFocusedFrame !== focusedFrame) {
 		d3.selectAll(".highlighted").classed("highlighted", false);
     	frameData[focusedFrame].brush.clear();
     }
//     	console.log("old " + frameData[focusedFrame].brush.empty());
//	console.log("new " + frameData[newFocusedFrame].brush.empty());
     focusedFrame = newFocusedFrame;
     //prevCell = cell;
    //cell.call(brush.clear());
	
	//d3.select(this).call(brush.clear());
	
}

  // Highlight the selected leaf links.
function brushmove() {
  	//console.log(this);
    var e = frameData[focusedFrame].brush.extent();
    var selectedNodes = [];
    
    d3.select(this.parentNode)
    	.selectAll(".leaf")
    	.each(function(d) {
    		if (frameData[focusedFrame].y(e[0]) < frameData[focusedFrame].y(d.x) && frameData[focusedFrame].y(d.x) < frameData[focusedFrame].y(e[1])) {
    			selectedNodes.push(d);
    		}
    	});
    	
    	
    d3.selectAll("svg")
    	.selectAll(".leaf")
      	.style("fill", function(d) {
      		if (containsLeaf(selectedNodes, d)) {
      			return "orange";
      		} else {
     			return "#000";
      		}
      	});
    
    addContainingNodes(selectedNodes);
    
    //could make this a bit faster by saving previous selection
   	d3.select(this.parentNode).selectAll("path.link").classed("highlighted", false);
   	
   	d3.select(this.parentNode).selectAll("path.link")
    	.data(getNodeLinks(selectedNodes), getLinkKey)
    	.classed("highlighted", true);
    	
   
    
    // d3.select(this.parentNode)
//     	.selectAll("path.link").classed("highlighted", function(d) {
//     	if (!d.target.children && frameData[focusedFrame].y(e[0]) < frameData[focusedFrame].y(d.target.x) && frameData[focusedFrame].y(d.target.x) < frameData[focusedFrame].y(e[1])) {
//           //&& (e[0][0]) < frameData[focusedFrame].x(d.target.rootDist) && frameData[focusedFrame].x(d.target.rootDist) < (e[1][0])) {
//           	selectedNodes.push(d);
//           	return true;
//           } else {
//           	return false;
//           }
//     });
    
    
    

    		
}

  // If the brush is empty, un-highlight all links.
function brushend() {
    if (frameData[focusedFrame].brush.empty()) d3.select(this.parentNode)
    					.selectAll(".highlighted").classed("highlighted", false);
}

function addContainingNodes(nodes) {
	var cont = true;
	while(cont) {
		var newElements = []
		cont = false;
		for (var i = 0; i < nodes.length; i++) {
			if (nodes[i].parent.children[0] == nodes[i]) {
				if (contains(nodes, nodes[i].parent.children[1]) && !contains(nodes, nodes[i].parent)) {
					nodes.push(nodes[i].parent);	//editing array while iterating over it...
					cont = true;
				}
			} else {
				if (contains(nodes, nodes[i].parent.children[0]) && !contains(nodes, nodes[i].parent)) {
					nodes.push(nodes[i].parent);
					cont = true;
				}
			}
		}
		nodes = nodes.concat(newElements);
	}
}
  

var getNodeKey = function(d, i) {
	return (d.name ? d.name : i);
}


var getLinkKey = function(d, i) {
	return (d.target.name ? d.target.name : i);
}

function contains(a, obj) {
	for (var i = 0; i < a.length; i++) {
		if (a[i] === obj) {
			return true;
		}
	}
	return false;
}

function containsLeaf(a, obj) {
	for (var i = 0; i < a.length; i++) {
		if (a[i].name === obj.name) {
			return true;
		}
	}
	return false;
}





//these functions were made just for testing..
//probably not useful for the final version

function sortLeaves() {
	if (sortedAscending) {
		cluster.sort(function(a,b) { return d3.descending(a.name, b.name)} );
		sortedAscending = false;
	} else {
		cluster.sort(function(a,b) { return d3.ascending(a.name, b.name)} );
		sortedAscending = true;
	}
	
	var nodes = cluster.nodes(root);

		
	var link = svg.selectAll("path.link")
		.data(cluster.links(nodes), getLinkKey)
		.transition()
		.duration(1000)
		.attr("d", elbow);
	
	svg.select("#root")
		.transition()
		.duration(1000)
		.attr("d", "M" + root.y + "," + y(root.x) + "h" + -20);


	var node = svg.selectAll("g.node")
		.data(nodes, getNodeKey)
		.transition()
		.duration(1000)
		.attr("transform", function(d) { return "translate(" + d.y + "," + y(d.x) + ")"; })
	
	
}

var highlight = function() {
	var selectedNodes = cluster.nodes(this.__data__.target);
	//console.log(selectedNodes)
	
  svg.selectAll("path.link")
    .data(cluster.links(selectedNodes), getLinkKey)
	.style("stroke", "orange")
	.style("stroke-width", "2.5px");
}

var unHighlight = function() {
	var selectedNodes = cluster.nodes(this.__data__.target);
	//console.log(selectedNodes)
	
  svg.selectAll("path.link")
    .data(cluster.links(selectedNodes), getLinkKey)
	.style("stroke", "#000")
	.style("stroke-width", "1px");
}



</script>
</body></html>