<!DOCTYPE html>
<!-- basic drawing capability taken from url=(0040)http://bl.ocks.org/mbostock/raw/2429963/ -->
<!-- some tree stuff inspired by https://gist.github.com/kueda/1036776 -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8">
		<title>A tree</title>
		<link rel="stylesheet" type="text/css" href="stylesheets/treeStyles.css">
		<script src="javascript/d3.v3.min.js"></script>
	</head>
<body>
<!-- <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->


<script>

var width = 400,
    height = 500;
    
var frameData = [];
	
//var sortedAscending = false;



	
//d3.select("p")
//	.on("click", sortLeaves);

var counter = 0;
var focusedFrame = 0;
	
var inputFiles = ["data/tree1.json", "data/tree2.json"];
//var inputFiles = ["data/testTree2.json", "data/testTree2.json"];



//read each input file and draw the tree in its own div
for (var i = 0; i < inputFiles.length; i++) {
	console.log("reading " + inputFiles[i]);
	initializeTree(inputFiles[i]);
}



	
function initializeTree(filename) {
	d3.json(filename, function(root) {
	//root is the root node of the input tree
		//initialize d3 cluster layout
		var cluster = d3.layout.cluster()
		    .size([height, width - 100])
			.separation( function(a, b) { return 1; } );

		//get an array of all nodes and where they should be placed 
		//(ignoring branch lengths)
		var nodes = cluster.nodes(root);

		var xScale = scaleBranchLengths(nodes, width-100);
		
		var yScale = d3.scale.linear()
			.domain([0, height])
			.range([0, height]);
		
		var brush = d3.svg.brush()
			.x(xScale)
			.y(yScale)
	    	.on("brushstart", brushstart)
		    .on("brush", brushmove)
    		.on("brushend", brushend);
	
		var div = d3.select("body").append("div")
			.attr("class", "svgBox");
	
		var svg = div.append("svg")
			.attr("id", counter)	//append a number to later identify this svg
			.attr("width", width)
			.attr("height", height)
			.call(brush)
		    .append("g")
				.attr("transform", "translate(35, 0)")

		var zoom = d3.behavior.zoom()
			//.x(xScale)
			.y(yScale)
			.on("zoom", zoomed)		
			.scaleExtent([1, 10]);
			
		frameData.push({x:xScale, y:yScale, brush:brush, zoom:zoom});
		
		var links = svg.selectAll("path.link")
			.data(cluster.links(nodes), getLinkKey)
		.enter().append("path")
		    .attr("class", "link")
			.attr("d", elbow)
		  //.on("mouseover", highlight)
		  //.on("mouseout", unHighlight);

		//assign node classification and position it
		var node = svg.selectAll("g.node")
			.data(nodes, getNodeKey)
		.enter().append("g")
			.attr("class", function(d) {
				if (d.children) {
					if (d.depth == 0) {
						return "root node";
					} else {
						return "inner node";
					}
				} else {
					return "leaf node";
				}
			} )
		 	.attr("transform", function(d) { return "translate(" + (d.y) + "," + yScale(d.x) + ")"; });
			
		//draw root node line. It is placed inside the root nodes g so it transforms along with it.
	    svg.select(".root") 
			.append("path")
	    	.attr("class", "rootLink")
			.attr("d", function(d) {return "M" + 0 + "," + 0 + "h" + -20; });		

		svg.selectAll(".leaf").append("text")
			.attr("dx", 8)
			.attr("dy", 3)
			.attr("text-anchor", "start" )
			.text(function(d) { return d.name; });
		
		svg.selectAll(".leaf").append("path")
			.attr("class", "dashedLink")
			.attr("d", dashedElbow);	
			
		svg.append("rect")
			.attr("class", "scrollArea")
			.attr("x", width - 60)
			.attr("y", 0)
			.attr("rx", 10)
			.attr("ry", 10)
			.attr("width", 20)
			.attr("height", height)	
			.call(zoom)
			
		counter++;
		focusedFrame = counter;
	});
}


var elbow = function(d, i) {
  return "M" + frameData[focusedFrame].x(d.source.rootDist) + "," + frameData[focusedFrame].y(d.source.x)
      + "V" + frameData[focusedFrame].y(d.target.x) + "H" + frameData[focusedFrame].x(d.target.rootDist);
}

var dashedElbow = function(d, i) {
	return "M" + 0 + "," + 0
    	+ "h" + (frameData[focusedFrame].x(d.rootDist) - d.y);
}

function scaleBranchLengths(nodes, w) {
	// Visit all nodes and adjust y pos width distance metric
	var visitPreOrder = function(root, callback) {
    	callback(root);
    	if (root.children) {
        	for (var i = 0; i < root.children.length; i++){
          		visitPreOrder(root.children[i], callback);
        	};
      	}
    }
    
    visitPreOrder(nodes[0], function(node) {
      node.rootDist = (node.parent ? node.parent.rootDist : 0) + (node.length || 0);
    });
    
    var rootDists = nodes.map(function(n) { return n.rootDist; });
    var yscale = d3.scale.linear()
      .domain([0, d3.max(rootDists)])
      .range([0, w]);
      
    //visitPreOrder(nodes[0], function(node) {
    //  node.y = yscale(node.rootDist);
    //});
    
    return yscale;
}


function zoomed() {
	var svg = d3.select(this.parentNode);
	focusedFrame = this.parentNode.parentNode.id;
	//if (!brush.empty())
	//	svg.call(brush.clear());
	
	var link = svg.selectAll("path.link")
		.attr("d", elbow);

	var node = svg.selectAll("g.node")
		.attr("transform", function(d) { return "translate(" + (d.y) + "," + frameData[focusedFrame].y(d.x) + ")"; })
}

var prevCell;

// Clear the previously-active brush, if any.
function brushstart(p) {
 	var cell = d3.select(this);
	focusedFrame = this.id;
 
 	if (prevCell && prevCell !== cell) {
 		prevCell.selectAll(".highlighted").classed("highlighted", false);
     	prevCell.call(frameData[focusedFrame].brush.clear());
     }
     prevCell = cell;
    //cell.call(brush.clear());
	
	//d3.select(this).call(brush.clear());
  }

  // Highlight the selected circles.
  function brushmove() {
  	//console.log(this);
    var e = frameData[focusedFrame].brush.extent();
    var selectedLeaves = [];
    d3.select(this)
    	.selectAll("path.link").classed("highlighted", function(d) {
    	if (frameData[focusedFrame].y(e[0][1]) < frameData[focusedFrame].y(d.target.x) && frameData[focusedFrame].y(d.target.x) < frameData[focusedFrame].y(e[1][1])
          && (e[0][0]) < frameData[focusedFrame].x(d.target.rootDist) && frameData[focusedFrame].x(d.target.rootDist) < (e[1][0])) {
          	selectedLeaves.push(d.target.name);
          	console.log("Selecting");
          	return true;
          } else {
          	return false;
          }
    });
    
    d3.selectAll("svg")
    	.selectAll(".leaf")
    	.style("fill", function(d) {
    		if (contains(selectedLeaves, d.name)) {
    			return "orange";
    		} else {
    			return "#000";
    		}
    	});
    		
  }

  // If the brush is empty, select all circles.
  function brushend() {
    if (frameData[focusedFrame].brush.empty()) d3.select(this)
    					.selectAll(".highlighted").classed("highlighted", false);
}
  

var getNodeKey = function(d, i) {
	return (d.name ? d.name : i);
}


var getLinkKey = function(d, i) {
	return (d.target.name ? d.target.name : i);
}

function contains(a, obj) {
	for (var i = 0; i < a.length; i++) {
		if (a[i] == obj) {
			return true;
		}
	}
	return false;
}





//these functions were made just for testing..
//probably not useful for the final version

function sortLeaves() {
	if (sortedAscending) {
		cluster.sort(function(a,b) { return d3.descending(a.name, b.name)} );
		sortedAscending = false;
	} else {
		cluster.sort(function(a,b) { return d3.ascending(a.name, b.name)} );
		sortedAscending = true;
	}
	
	var nodes = cluster.nodes(root);

		
	var link = svg.selectAll("path.link")
		.data(cluster.links(nodes), getLinkKey)
		.transition()
		.duration(1000)
		.attr("d", elbow);
	
	svg.select("#root")
		.transition()
		.duration(1000)
		.attr("d", "M" + root.y + "," + y(root.x) + "h" + -20);


	var node = svg.selectAll("g.node")
		.data(nodes, getNodeKey)
		.transition()
		.duration(1000)
		.attr("transform", function(d) { return "translate(" + d.y + "," + y(d.x) + ")"; })
	
	
}

var highlight = function() {
	var selectedNodes = cluster.nodes(this.__data__.target);
	//console.log(selectedNodes)
	
  svg.selectAll("path.link")
    .data(cluster.links(selectedNodes), getLinkKey)
	.style("stroke", "orange")
	.style("stroke-width", "2.5px");
}

var unHighlight = function() {
	var selectedNodes = cluster.nodes(this.__data__.target);
	//console.log(selectedNodes)
	
  svg.selectAll("path.link")
    .data(cluster.links(selectedNodes), getLinkKey)
	.style("stroke", "#000")
	.style("stroke-width", "1px");
}



</script>
</body></html>